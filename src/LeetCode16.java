/*给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，
使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

        例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.

        与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).

 */
/*
思路：首先就是，如果数组最后一位是小于9的，则只需将数组最后一位加1就可以直接输出了。
        2、其次就是，当数组的最后一位是9时，当加1之后就会变成10，所以我们可以对整个遍历，
        从后往前遍历，只要加1等于10，则将该位置赋值为0，并将前一位加1，一直循环到第0位，
        如果第0位不等于10，则直接输出当前数组，否则就是第三种情况。
        3、最后判断如果数组下标0位置的值是10，则我们需要对数组进行扩容，
        创建一个新数组，让数组的下标0的值为1，下标1的值为0，其它下标的值则和原先的数组值一摸一样，然后将新数组输出。
*/

public class LeetCode16 {

        public int[] plusOne(int[] digits) {
            //首先就是获取当前数组的长度
            int n = digits.length;
            //将数组最后一位加1
            digits[n - 1] = digits[n - 1] + 1;
            //只要最后一位小于10，则直接输出当前数组
            if(digits[n - 1] < 10){
                return digits;
            }
            //如果最后一位值为10，则对整个数组进行遍历
            for(int i = n - 1; i >= 1; i--){
                if(digits[i] == 10){	//只要当前下标值等于10，就让当前下标值为0，并让前一个下标值加1
                    digits[i] = 0;
                    digits[i - 1] = digits[i - 1] + 1;	//让前一个下标值加1
                }
            }
            //如果下标0的值为10，则需要创建一个新数组，容量比当前多1
            if(digits[0] == 10){
                int[] newDigits = new int[n + 1];
                newDigits[0] = 1;	//赋值下标0的值为1
                newDigits[1] = 0;	//赋值下标1的值为0
                for(int i = n; i >= 2; i--){	//进行循环，将之前的数组的值赋值给新数组，除了下标0和下标1
                    newDigits[i] = digits[i - 1];
                }
                return newDigits;
            }
            return digits;
        }
    }


